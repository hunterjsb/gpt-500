// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createHolding = `-- name: CreateHolding :one
INSERT INTO portfolio_holdings (ticker, name, weight, comment, price, return)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING ticker, name, weight, comment, price, updated_dt, added_dt, return
`

type CreateHoldingParams struct {
	Ticker  string
	Name    string
	Weight  string
	Comment sql.NullString
	Price   string
	Return  sql.NullString
}

func (q *Queries) CreateHolding(ctx context.Context, arg CreateHoldingParams) (PortfolioHolding, error) {
	row := q.db.QueryRowContext(ctx, createHolding,
		arg.Ticker,
		arg.Name,
		arg.Weight,
		arg.Comment,
		arg.Price,
		arg.Return,
	)
	var i PortfolioHolding
	err := row.Scan(
		&i.Ticker,
		&i.Name,
		&i.Weight,
		&i.Comment,
		&i.Price,
		&i.UpdatedDt,
		&i.AddedDt,
		&i.Return,
	)
	return i, err
}

const deleteHolding = `-- name: DeleteHolding :exec
DELETE FROM portfolio_holdings WHERE ticker = $1
`

func (q *Queries) DeleteHolding(ctx context.Context, ticker string) error {
	_, err := q.db.ExecContext(ctx, deleteHolding, ticker)
	return err
}

const getAllHoldings = `-- name: GetAllHoldings :many
SELECT ticker, name, weight, comment, price, updated_dt, added_dt, return
FROM portfolio_holdings
ORDER BY weight DESC
`

func (q *Queries) GetAllHoldings(ctx context.Context) ([]PortfolioHolding, error) {
	rows, err := q.db.QueryContext(ctx, getAllHoldings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PortfolioHolding
	for rows.Next() {
		var i PortfolioHolding
		if err := rows.Scan(
			&i.Ticker,
			&i.Name,
			&i.Weight,
			&i.Comment,
			&i.Price,
			&i.UpdatedDt,
			&i.AddedDt,
			&i.Return,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHolding = `-- name: GetHolding :one
SELECT ticker, name, weight, comment, price, updated_dt, added_dt, return
FROM portfolio_holdings
WHERE ticker = $1
`

func (q *Queries) GetHolding(ctx context.Context, ticker string) (PortfolioHolding, error) {
	row := q.db.QueryRowContext(ctx, getHolding, ticker)
	var i PortfolioHolding
	err := row.Scan(
		&i.Ticker,
		&i.Name,
		&i.Weight,
		&i.Comment,
		&i.Price,
		&i.UpdatedDt,
		&i.AddedDt,
		&i.Return,
	)
	return i, err
}

const getPortfolioSummary = `-- name: GetPortfolioSummary :one
SELECT 
    COALESCE(SUM(weight), 0) as total_weight,
    COUNT(*) as holding_count,
    COALESCE(AVG(return), 0) as avg_return
FROM portfolio_holdings
`

type GetPortfolioSummaryRow struct {
	TotalWeight  interface{}
	HoldingCount int64
	AvgReturn    interface{}
}

func (q *Queries) GetPortfolioSummary(ctx context.Context) (GetPortfolioSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getPortfolioSummary)
	var i GetPortfolioSummaryRow
	err := row.Scan(&i.TotalWeight, &i.HoldingCount, &i.AvgReturn)
	return i, err
}

const updateHolding = `-- name: UpdateHolding :one
UPDATE portfolio_holdings 
SET name = COALESCE($2, name),
    weight = COALESCE($3, weight), 
    price = COALESCE($4, price),
    comment = COALESCE($5, comment),
    return = COALESCE($6, return),
    updated_dt = now()
WHERE ticker = $1
RETURNING ticker, name, weight, comment, price, updated_dt, added_dt, return
`

type UpdateHoldingParams struct {
	Ticker  string
	Name    string
	Weight  string
	Price   string
	Comment sql.NullString
	Return  sql.NullString
}

func (q *Queries) UpdateHolding(ctx context.Context, arg UpdateHoldingParams) (PortfolioHolding, error) {
	row := q.db.QueryRowContext(ctx, updateHolding,
		arg.Ticker,
		arg.Name,
		arg.Weight,
		arg.Price,
		arg.Comment,
		arg.Return,
	)
	var i PortfolioHolding
	err := row.Scan(
		&i.Ticker,
		&i.Name,
		&i.Weight,
		&i.Comment,
		&i.Price,
		&i.UpdatedDt,
		&i.AddedDt,
		&i.Return,
	)
	return i, err
}
